1. 배열과 포인터의 차이점

가) 배열은 배열의 시작주소를 바꿀 수 없다.( 정적할당 ), 포인터변수는 값(주소)을 변경할 수 있다.

#include <stdio.h>

int main() {
	int data[] = { 10, 20, 30, 40, 50 };
	int* p = data;
            printf("%d   %d \n", &data, data[0]);
	printf("%d   %d   %d\n", &p, p, p[0]);

	p++;

	printf("%d   %d   %d\n", &p, p, p[0]);	
	printf("%d", p[0]);

	return 0;
}


나) 배열은 문자열 일부 바꿀 수 있고, 포인터변수로는 문자열 일부 변경 불가.
 
< char 배열 사용 > : 배열은 문자열 일부 변경 가능

#include <stdio.h>

char buf[] = "abcdefg";

int main() {
	*(buf) = '*';          // *(buf+2) = '*';    ab*defg
	printf("%s\n", buf);

	return 0;
}

결과 : *bcdefg

< char* 사용 > ; 포인터변수는 문자열 일부를 바꿀 수 없음.

#include <stdio.h>

char *buf = "abcdefg";

int main() {
	*(buf) = '*';
	printf("%s\n", buf);

	return 0;
}

결과 : Runtime error
 *buf 가 문자열 상수를 바꾸려고 하기 때문...

다른 문자열로 상수 자체를 바꿀 수 있음.
< 아래 결과로 메모리 맵을 그려보세요. >

#include <stdio.h>

char *buf = "abcdefg";

int main() {
	printf("%d   %d   %s\n", &buf, buf, buf);
	buf = "Good";
	printf("%d   %d   %s\n", &buf, buf, buf);	
	printf("%s\n", buf);

	return 0;
}

2. 문자열과 포인터

가. 포인터가 문자열을 가리키게 하면, 포인터 연산으로 문자열의 일부 변경 가능.
    포인터에 문자열을 할당하면, 새로운 메모리 공간을 할당받아 저장함.

< 실행 후 메모리 맵 그려 보세요 >

#include <stdio.h>

int main() {
	char data[] = "Hello World!";
	char* p;
        printf("%d   %d   %s\n", &data, data, data);
        printf("%d   %d     \n", &p, p);
    
	p = data;
	printf("%s    %s\n", p, data);
	printf("%d   %d\n", &p, p);
	
	int i; 
	for (i = 0; i<sizeof(data); i++)         // 문자열을 하나씩 출력한다.  
		printf("%c", *(p + i));
	printf("\n\n");
		 
	data[0] = '*';
	printf("%s\n", p);

	*(p+2) = '+';
	printf("%s\n", p);
	
	p = "Good days";
	printf("%d   %d   %s\n", &p, p, p);
	
	return 0;
}


나. const 문자열과 포인터 : const 문자열 배열은 수정불가, but 연결된 포인터로 접근하면 수정 가능함. 

#include <stdio.h>

int main() {
	const char data[] = "Hello World!";
	char* p;
    printf("%d   %d   %s\n", &data, data, data);
    printf("%d   %d     \n", &p, p);
    
	p = data;
	printf("%s    %s\n", p, data);
	printf("%d   %d\n", &p, p);
	
	// data[0] = '*';             // data[]문자열(배열)은 const이므로 수정 불가. 
	// printf("%s\n", p);

	*(p+2) = '+';                // 포인터 p로 접근하면 연결된 배열이 상수(const)라도 변경 가능 : 이렇게 하면 안됨니다. 
	printf("%s\n", p);
	
	p = "Good days";
	printf("%d   %d   %s\n", &p, p, p);
	
	return 0;
}

다. 나 프로그램을 const char* p; 로 선언하면 포인터로 변경 불가.

#include <stdio.h>

int main() {
	const char data[] = "Hello World!";
	const char* p;
        printf("%d   %d   %s\n", &data, data, data);
        printf("%d   %d     \n", &p, p);
    
	p = data;
	printf("%s    %s\n", p, data);
	printf("%d   %d\n", &p, p);
	
	// data[0] = '*';             // data[]배열은 const이므로 수정 불가. 
	// printf("%s\n", p);

	// *(p+2) = '+';                // const 포인터 p이므로 변경 불가능  
	// printf("%s\n", p);
	
	p = "Good days";               // 전체 문자열을 할당할 수 있음.   
	printf("%d   %d   %s\n", &p, p, p);
	
	return 0;
}

3. 포인터와 동적 메모리

가. 함수가 문자 포인터형이라도 지역변수로 선언된 문자열(배열)은 함수가 종료되면 삭제됨. 

#include <stdio.h>

char* inputName() {
	char name[100];                                // name[] 배열은 지역변수이므로 inputName()함수 종료시
                                                       // 메모리에서 삭제됨 ( 운영체제로 반납되어 접근할 수 없음(Garbage)
	scanf("%s", name);
        printf("%d   %d   %s\n", &name, name, name);
    
	return name;
}

int main() {
	char* p;

	p = inputName();
	printf("%d   %d   %s\n", &p, p, p);           // name[]배열의 주소를 p에 할당되나, 포인터 p로 읽을 수 없음(이미 메모리에서 삭제됨).
	printf("%s", p);

	return 0;
}

결과 :
입력 : Hellow
출력 : (null)    ==> 값이 출력되지 않음.


나. 함수가 int 형일 경우

#include <stdio.h>

int inputNumber() {
	int number;
    
	scanf("%d", &number);
    printf("%d   %d\n", &number, number);
	  
	return number;
}

int main() {
	int number;
    printf("%d   %d\n", &number, number);
    
	number = inputNumber();                // inputNumber()함수가 int 타입이므로 입력 값(number)이 main의 number에 할당됨.   
	printf("%d   %d\n", &number, number);
	printf("%d", number);

	return 0;
}

결과
입력 : 300
출력 : 300


다. 가. 문제 해결방법 ==> 동적 할당


#include <stdio.h>
#include <stdlib.h>               // 표준라이브러리 헤더파일 추가 
 
char* inputName() {
	char* name;                   // 포인터 선언                      
	              
	name = (char *)malloc(sizeof(char) * 100);	 // 포인터에 동적 할당, 포인터를 free()함수가 실행되기 전에는 메모리 할당된 상태로 있음. 
	scanf("%s", name);
        printf("%d   %d   %s\n", &name, name, name);
    
	return name;
}

int main() {
	char* p;

	p = inputName();                               // inputName()함수에서 return된 포인터 변수 name의 주소가 p에 할당됨.   
	printf("%d   %d   %s\n", &p, p, p);            // inputName()함수 종료와 함께 지역변수 포인터 변수 name도 메모리에서 삭제됨. 
	printf("%s", p);
    
        free(p);                                     // 메모리 해제  
        p=NULL;
    
	return 0;
}

라. 동적할당 사용 이유 : 사용할 데이터의 갯수 만큼 메모리 할당

#include <stdio.h>
#include <stdlib.h>

int main() {
	int size;
	int* inputData = NULL;

	printf("몇 개의 정수를 입력합니까?\n");
	scanf("%d", &size);

	// 사용자가 입력할 개수만큼 메모리 할당
	inputData = (int *)malloc(sizeof(int)*size);
	printf("%d   %d   %d\n", &inputData, inputData, sizeof(inputData[0])*size );  
	
	// 메모리 할당이 정상적이지 않는 경우를 경험해 본 적이 없다. 그러나, 로직상 표현
	if (inputData == NULL) {
		printf("memory allocation failed.\n");
		return -1;
	}

	// 동적으로 할당받은 메모리를 이용하여 입력받는다.
	printf(" %d 개의 정수를 입력합니다.\n", size);
	int i;
	for ( i = 0; i<size; i++) {
		scanf("%d", &inputData[i]);
	}

	printf("입력한 정수는 %d 개 입니다.\n", size);
	for ( i = 0; i<size; i++) {
		printf("%d ", inputData[i]);
	}

	// 메모리 해제
	free(inputData);
	inputData=NULL; 

	return 0;
}

 
4. 포인터 배열

< 결과로 메모리 맵을 그려보세요. >

#include <stdio.h>

int main() {
	char* classes[3] = {
		"컴퓨터 프로그래밍",
		"자료구조",
		"컴퓨터 알고리즘"
	};
    int i; 
	for ( i = 0; i<3; i++) {                                   // 포인터배열의 주소, data 출력 
		printf("%d    %d    %s\n", &classes[i], classes[i], classes[i]);
	}
	
	for ( i = 0; i<3; i++) {
		printf("%s\n", classes[i]);
	}

	return 0;
}

5. 이중 포인터 및 &, * 연산자

#include <stdio.h>

int main() {
	int i = 50;
	int* p = &i;
	int** pp = &p;
	printf("i의 주소 = %d,  data = %d\n", &i, i); 
            printf("p의 주소 = %d,  data = %d,  *p = %d, pp의 주소 = %d, data = %d, *pp = %d, **pp = %d\n", &p, p, *p, &pp, pp, *pp, **pp); 

	i = 100;
	printf("%d %d %d\n", i, *p, **pp);
            printf("p의 주소 = %d,  data = %d,  *p = %d, pp의 주소 = %d, data = %d, *pp = %d, **pp = %d\n", &p, p, *p, &pp, pp, *pp, **pp); 

	*p = 200;
	printf("%d %d %d\n", i, *p, **pp);
            printf("p의 주소 = %d,  data = %d,  *p = %d, pp의 주소 = %d, data = %d, *pp = %d, **pp = %d\n", &p, p, *p, &pp, pp, *pp, **pp); 
    
	**pp = 300;
	printf("%d %d %d\n", i, *p, **pp);
            printf("p의 주소 = %d,  data = %d,  *p = %d, pp의 주소 = %d, data = %d, *pp = %d, **pp = %d\n", &p, p, *p, &pp, pp, *pp, **pp);
	
	printf("\n\n");
	printf("*p = %d, &*p = %d, *&*p = %d, &*&*p = %d, *(&(**pp)) = %d\n", *p, &*p, *&*p, &*&*p, *(&(**pp)));  
    
	return 0;
}

6. 연결 리스트 ( 자기참조 구조체 )

#include <stdio.h>
#include <stdlib.h>
typedef struct node {
	int data;
	struct node *link;
        } node;
node *new_node=NULL, *head=NULL, *temp=NULL;

int main(void) {
	int num;
	printf("*new_node  의 주소= %d, 데이터= %x \n", &new_node, new_node);
	printf("*head      의 주소= %d, 데이터= %x \n", &head, head);
	printf("*temp      의 주소= %d, 데이터= %x \n", &temp, temp);
	
	new_node = (node *)malloc(sizeof(node));
	new_node->data = 1;
	new_node->link = NULL;
	head = temp = new_node;
	printf("*head 의 값= %d, *temp의 값= %d \n", &head->data, &temp->data);
	printf("new_node->data 의 주소= %d, 데이터= %d \n", &new_node->data, new_node->data);
	
	num = 2;
	while (num <= 10) {
		new_node = (node *)malloc(sizeof(node));
		if (new_node == NULL) {
			printf("memory allocation error\n");
			return(0);
		}
		new_node->data = num;
		new_node->link = NULL;
		temp->link = new_node;
		temp = new_node;
		num = num + 1;
		printf("new_node->data 의 주소= %d, 데이터= %d \n", &new_node->data, new_node->data);
	}

	temp = head;
	while (temp != NULL) {
		printf("%d, %d\n", temp->data, &temp->data);
		temp = temp->link;
	     }
	system("pause");
}

7, 포인터 변수의 장점 ( 포인터 변수 사용하여야 하는 이유 )

-. 하나의 포인터 변수는 포인터가 아닌 배열 개체 하나를 대치할 수 있다.

-. 포인터를 사용하면 어떤 함수에서 값을 배열로 반환해야할 때 구조체(struct), 공용체(union) 따위로 의미없이 포장할 필요가 없다.

-. 함수가 반환할 값이 함수가 끝나고 나면 없어져야 할 값이 아니라면 포인터로 반환해서 계속 사용할 수 있다.

-. 프로그램의 입력값이나 조건에 따라서 적정한 용량의 배열을 동적으로 할당하는 것은 포인터만이 가능하다.

-. 포인터 변수는 배열의 시작 주소를 가지기 때문에 포인터 변수 하나로 개체 전체를 사용할 수 있게 한다.